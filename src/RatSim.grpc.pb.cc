// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: RatSim.proto

#include "RatSim.pb.h"
#include "RatSim.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/sync_stream.h>
namespace RatSim {

static const char* LidarService_method_names[] = {
  "/RatSim.LidarService/GetLiDARData",
  "/RatSim.LidarService/GetLiDAROdom",
  "/RatSim.LidarService/GetLiDARDataAndOdom",
};

std::unique_ptr< LidarService::Stub> LidarService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< LidarService::Stub> stub(new LidarService::Stub(channel, options));
  return stub;
}

LidarService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetLiDARData_(LidarService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetLiDAROdom_(LidarService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetLiDARDataAndOdom_(LidarService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status LidarService::Stub::GetLiDARData(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::RatSim::LidarData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::RobotName, ::RatSim::LidarData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetLiDARData_, context, request, response);
}

void LidarService::Stub::async::GetLiDARData(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::LidarData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::RobotName, ::RatSim::LidarData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDARData_, context, request, response, std::move(f));
}

void LidarService::Stub::async::GetLiDARData(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::LidarData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDARData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::LidarData>* LidarService::Stub::PrepareAsyncGetLiDARDataRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::LidarData, ::RatSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetLiDARData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::LidarData>* LidarService::Stub::AsyncGetLiDARDataRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetLiDARDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status LidarService::Stub::GetLiDAROdom(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::RatSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetLiDAROdom_, context, request, response);
}

void LidarService::Stub::async::GetLiDAROdom(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDAROdom_, context, request, response, std::move(f));
}

void LidarService::Stub::async::GetLiDAROdom(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDAROdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Odometry>* LidarService::Stub::PrepareAsyncGetLiDAROdomRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::Odometry, ::RatSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetLiDAROdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Odometry>* LidarService::Stub::AsyncGetLiDAROdomRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetLiDAROdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status LidarService::Stub::GetLiDARDataAndOdom(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::RatSim::LidarDataAndOdom* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::RobotName, ::RatSim::LidarDataAndOdom, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetLiDARDataAndOdom_, context, request, response);
}

void LidarService::Stub::async::GetLiDARDataAndOdom(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::LidarDataAndOdom* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::RobotName, ::RatSim::LidarDataAndOdom, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDARDataAndOdom_, context, request, response, std::move(f));
}

void LidarService::Stub::async::GetLiDARDataAndOdom(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::LidarDataAndOdom* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetLiDARDataAndOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::LidarDataAndOdom>* LidarService::Stub::PrepareAsyncGetLiDARDataAndOdomRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::LidarDataAndOdom, ::RatSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetLiDARDataAndOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::LidarDataAndOdom>* LidarService::Stub::AsyncGetLiDARDataAndOdomRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetLiDARDataAndOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

LidarService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LidarService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LidarService::Service, ::RatSim::RobotName, ::RatSim::LidarData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](LidarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::RobotName* req,
             ::RatSim::LidarData* resp) {
               return service->GetLiDARData(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LidarService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LidarService::Service, ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](LidarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::RobotName* req,
             ::RatSim::Odometry* resp) {
               return service->GetLiDAROdom(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      LidarService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< LidarService::Service, ::RatSim::RobotName, ::RatSim::LidarDataAndOdom, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](LidarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::RobotName* req,
             ::RatSim::LidarDataAndOdom* resp) {
               return service->GetLiDARDataAndOdom(ctx, req, resp);
             }, this)));
}

LidarService::Service::~Service() {
}

::grpc::Status LidarService::Service::GetLiDARData(::grpc::ServerContext* context, const ::RatSim::RobotName* request, ::RatSim::LidarData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LidarService::Service::GetLiDAROdom(::grpc::ServerContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status LidarService::Service::GetLiDARDataAndOdom(::grpc::ServerContext* context, const ::RatSim::RobotName* request, ::RatSim::LidarDataAndOdom* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* DepthCameraService_method_names[] = {
  "/RatSim.DepthCameraService/GetDepthCameraPointData",
  "/RatSim.DepthCameraService/GetDepthCameraImageData",
  "/RatSim.DepthCameraService/GetDepthCameraOdom",
};

std::unique_ptr< DepthCameraService::Stub> DepthCameraService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< DepthCameraService::Stub> stub(new DepthCameraService::Stub(channel, options));
  return stub;
}

DepthCameraService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetDepthCameraPointData_(DepthCameraService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetDepthCameraImageData_(DepthCameraService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetDepthCameraOdom_(DepthCameraService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status DepthCameraService::Stub::GetDepthCameraPointData(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::RatSim::DepthCameraPointData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::RobotName, ::RatSim::DepthCameraPointData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDepthCameraPointData_, context, request, response);
}

void DepthCameraService::Stub::async::GetDepthCameraPointData(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::DepthCameraPointData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::RobotName, ::RatSim::DepthCameraPointData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraPointData_, context, request, response, std::move(f));
}

void DepthCameraService::Stub::async::GetDepthCameraPointData(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::DepthCameraPointData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraPointData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::DepthCameraPointData>* DepthCameraService::Stub::PrepareAsyncGetDepthCameraPointDataRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::DepthCameraPointData, ::RatSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDepthCameraPointData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::DepthCameraPointData>* DepthCameraService::Stub::AsyncGetDepthCameraPointDataRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDepthCameraPointDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status DepthCameraService::Stub::GetDepthCameraImageData(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::RatSim::DepthCameraImageData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::RobotName, ::RatSim::DepthCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDepthCameraImageData_, context, request, response);
}

void DepthCameraService::Stub::async::GetDepthCameraImageData(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::DepthCameraImageData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::RobotName, ::RatSim::DepthCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraImageData_, context, request, response, std::move(f));
}

void DepthCameraService::Stub::async::GetDepthCameraImageData(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::DepthCameraImageData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraImageData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::DepthCameraImageData>* DepthCameraService::Stub::PrepareAsyncGetDepthCameraImageDataRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::DepthCameraImageData, ::RatSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDepthCameraImageData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::DepthCameraImageData>* DepthCameraService::Stub::AsyncGetDepthCameraImageDataRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDepthCameraImageDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status DepthCameraService::Stub::GetDepthCameraOdom(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::RatSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDepthCameraOdom_, context, request, response);
}

void DepthCameraService::Stub::async::GetDepthCameraOdom(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraOdom_, context, request, response, std::move(f));
}

void DepthCameraService::Stub::async::GetDepthCameraOdom(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDepthCameraOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Odometry>* DepthCameraService::Stub::PrepareAsyncGetDepthCameraOdomRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::Odometry, ::RatSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDepthCameraOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Odometry>* DepthCameraService::Stub::AsyncGetDepthCameraOdomRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDepthCameraOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

DepthCameraService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DepthCameraService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DepthCameraService::Service, ::RatSim::RobotName, ::RatSim::DepthCameraPointData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DepthCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::RobotName* req,
             ::RatSim::DepthCameraPointData* resp) {
               return service->GetDepthCameraPointData(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DepthCameraService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DepthCameraService::Service, ::RatSim::RobotName, ::RatSim::DepthCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DepthCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::RobotName* req,
             ::RatSim::DepthCameraImageData* resp) {
               return service->GetDepthCameraImageData(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DepthCameraService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DepthCameraService::Service, ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DepthCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::RobotName* req,
             ::RatSim::Odometry* resp) {
               return service->GetDepthCameraOdom(ctx, req, resp);
             }, this)));
}

DepthCameraService::Service::~Service() {
}

::grpc::Status DepthCameraService::Service::GetDepthCameraPointData(::grpc::ServerContext* context, const ::RatSim::RobotName* request, ::RatSim::DepthCameraPointData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DepthCameraService::Service::GetDepthCameraImageData(::grpc::ServerContext* context, const ::RatSim::RobotName* request, ::RatSim::DepthCameraImageData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DepthCameraService::Service::GetDepthCameraOdom(::grpc::ServerContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* RGBCameraService_method_names[] = {
  "/RatSim.RGBCameraService/GetRGBCameraImageData",
  "/RatSim.RGBCameraService/GetRGBCameraOdom",
};

std::unique_ptr< RGBCameraService::Stub> RGBCameraService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< RGBCameraService::Stub> stub(new RGBCameraService::Stub(channel, options));
  return stub;
}

RGBCameraService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetRGBCameraImageData_(RGBCameraService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetRGBCameraOdom_(RGBCameraService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status RGBCameraService::Stub::GetRGBCameraImageData(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::RatSim::RGBCameraImageData* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::RobotName, ::RatSim::RGBCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetRGBCameraImageData_, context, request, response);
}

void RGBCameraService::Stub::async::GetRGBCameraImageData(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::RGBCameraImageData* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::RobotName, ::RatSim::RGBCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBCameraImageData_, context, request, response, std::move(f));
}

void RGBCameraService::Stub::async::GetRGBCameraImageData(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::RGBCameraImageData* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBCameraImageData_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::RGBCameraImageData>* RGBCameraService::Stub::PrepareAsyncGetRGBCameraImageDataRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::RGBCameraImageData, ::RatSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetRGBCameraImageData_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::RGBCameraImageData>* RGBCameraService::Stub::AsyncGetRGBCameraImageDataRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetRGBCameraImageDataRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status RGBCameraService::Stub::GetRGBCameraOdom(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::RatSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetRGBCameraOdom_, context, request, response);
}

void RGBCameraService::Stub::async::GetRGBCameraOdom(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBCameraOdom_, context, request, response, std::move(f));
}

void RGBCameraService::Stub::async::GetRGBCameraOdom(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetRGBCameraOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Odometry>* RGBCameraService::Stub::PrepareAsyncGetRGBCameraOdomRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::Odometry, ::RatSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetRGBCameraOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Odometry>* RGBCameraService::Stub::AsyncGetRGBCameraOdomRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetRGBCameraOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

RGBCameraService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RGBCameraService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RGBCameraService::Service, ::RatSim::RobotName, ::RatSim::RGBCameraImageData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RGBCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::RobotName* req,
             ::RatSim::RGBCameraImageData* resp) {
               return service->GetRGBCameraImageData(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RGBCameraService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RGBCameraService::Service, ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RGBCameraService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::RobotName* req,
             ::RatSim::Odometry* resp) {
               return service->GetRGBCameraOdom(ctx, req, resp);
             }, this)));
}

RGBCameraService::Service::~Service() {
}

::grpc::Status RGBCameraService::Service::GetRGBCameraImageData(::grpc::ServerContext* context, const ::RatSim::RobotName* request, ::RatSim::RGBCameraImageData* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status RGBCameraService::Service::GetRGBCameraOdom(::grpc::ServerContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* DroneService_method_names[] = {
  "/RatSim.DroneService/GetDroneOdom",
  "/RatSim.DroneService/SendDronePose",
};

std::unique_ptr< DroneService::Stub> DroneService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< DroneService::Stub> stub(new DroneService::Stub(channel, options));
  return stub;
}

DroneService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetDroneOdom_(DroneService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendDronePose_(DroneService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status DroneService::Stub::GetDroneOdom(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::RatSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetDroneOdom_, context, request, response);
}

void DroneService::Stub::async::GetDroneOdom(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDroneOdom_, context, request, response, std::move(f));
}

void DroneService::Stub::async::GetDroneOdom(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetDroneOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Odometry>* DroneService::Stub::PrepareAsyncGetDroneOdomRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::Odometry, ::RatSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetDroneOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Odometry>* DroneService::Stub::AsyncGetDroneOdomRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetDroneOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status DroneService::Stub::SendDronePose(::grpc::ClientContext* context, const ::RatSim::DronePose& request, ::RatSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::DronePose, ::RatSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendDronePose_, context, request, response);
}

void DroneService::Stub::async::SendDronePose(::grpc::ClientContext* context, const ::RatSim::DronePose* request, ::RatSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::DronePose, ::RatSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendDronePose_, context, request, response, std::move(f));
}

void DroneService::Stub::async::SendDronePose(::grpc::ClientContext* context, const ::RatSim::DronePose* request, ::RatSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendDronePose_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Status>* DroneService::Stub::PrepareAsyncSendDronePoseRaw(::grpc::ClientContext* context, const ::RatSim::DronePose& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::Status, ::RatSim::DronePose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendDronePose_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Status>* DroneService::Stub::AsyncSendDronePoseRaw(::grpc::ClientContext* context, const ::RatSim::DronePose& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendDronePoseRaw(context, request, cq);
  result->StartCall();
  return result;
}

DroneService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DroneService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DroneService::Service, ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DroneService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::RobotName* req,
             ::RatSim::Odometry* resp) {
               return service->GetDroneOdom(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      DroneService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< DroneService::Service, ::RatSim::DronePose, ::RatSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](DroneService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::DronePose* req,
             ::RatSim::Status* resp) {
               return service->SendDronePose(ctx, req, resp);
             }, this)));
}

DroneService::Service::~Service() {
}

::grpc::Status DroneService::Service::GetDroneOdom(::grpc::ServerContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status DroneService::Service::SendDronePose(::grpc::ServerContext* context, const ::RatSim::DronePose* request, ::RatSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* CarService_method_names[] = {
  "/RatSim.CarService/GetCarOdom",
  "/RatSim.CarService/SendCarPose",
};

std::unique_ptr< CarService::Stub> CarService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< CarService::Stub> stub(new CarService::Stub(channel, options));
  return stub;
}

CarService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_GetCarOdom_(CarService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SendCarPose_(CarService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status CarService::Stub::GetCarOdom(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::RatSim::Odometry* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetCarOdom_, context, request, response);
}

void CarService::Stub::async::GetCarOdom(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetCarOdom_, context, request, response, std::move(f));
}

void CarService::Stub::async::GetCarOdom(::grpc::ClientContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetCarOdom_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Odometry>* CarService::Stub::PrepareAsyncGetCarOdomRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::Odometry, ::RatSim::RobotName, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetCarOdom_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Odometry>* CarService::Stub::AsyncGetCarOdomRaw(::grpc::ClientContext* context, const ::RatSim::RobotName& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetCarOdomRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CarService::Stub::SendCarPose(::grpc::ClientContext* context, const ::RatSim::DronePose& request, ::RatSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::DronePose, ::RatSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendCarPose_, context, request, response);
}

void CarService::Stub::async::SendCarPose(::grpc::ClientContext* context, const ::RatSim::DronePose* request, ::RatSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::DronePose, ::RatSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendCarPose_, context, request, response, std::move(f));
}

void CarService::Stub::async::SendCarPose(::grpc::ClientContext* context, const ::RatSim::DronePose* request, ::RatSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendCarPose_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Status>* CarService::Stub::PrepareAsyncSendCarPoseRaw(::grpc::ClientContext* context, const ::RatSim::DronePose& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::Status, ::RatSim::DronePose, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendCarPose_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Status>* CarService::Stub::AsyncSendCarPoseRaw(::grpc::ClientContext* context, const ::RatSim::DronePose& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendCarPoseRaw(context, request, cq);
  result->StartCall();
  return result;
}

CarService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CarService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CarService::Service, ::RatSim::RobotName, ::RatSim::Odometry, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::RobotName* req,
             ::RatSim::Odometry* resp) {
               return service->GetCarOdom(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CarService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CarService::Service, ::RatSim::DronePose, ::RatSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CarService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::DronePose* req,
             ::RatSim::Status* resp) {
               return service->SendCarPose(ctx, req, resp);
             }, this)));
}

CarService::Service::~Service() {
}

::grpc::Status CarService::Service::GetCarOdom(::grpc::ServerContext* context, const ::RatSim::RobotName* request, ::RatSim::Odometry* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CarService::Service::SendCarPose(::grpc::ServerContext* context, const ::RatSim::DronePose* request, ::RatSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* MeshService_method_names[] = {
  "/RatSim.MeshService/SendMesh",
};

std::unique_ptr< MeshService::Stub> MeshService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< MeshService::Stub> stub(new MeshService::Stub(channel, options));
  return stub;
}

MeshService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_SendMesh_(MeshService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status MeshService::Stub::SendMesh(::grpc::ClientContext* context, const ::RatSim::MeshData& request, ::RatSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::MeshData, ::RatSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendMesh_, context, request, response);
}

void MeshService::Stub::async::SendMesh(::grpc::ClientContext* context, const ::RatSim::MeshData* request, ::RatSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::MeshData, ::RatSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendMesh_, context, request, response, std::move(f));
}

void MeshService::Stub::async::SendMesh(::grpc::ClientContext* context, const ::RatSim::MeshData* request, ::RatSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendMesh_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Status>* MeshService::Stub::PrepareAsyncSendMeshRaw(::grpc::ClientContext* context, const ::RatSim::MeshData& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::Status, ::RatSim::MeshData, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendMesh_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Status>* MeshService::Stub::AsyncSendMeshRaw(::grpc::ClientContext* context, const ::RatSim::MeshData& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendMeshRaw(context, request, cq);
  result->StartCall();
  return result;
}

MeshService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MeshService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MeshService::Service, ::RatSim::MeshData, ::RatSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](MeshService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::MeshData* req,
             ::RatSim::Status* resp) {
               return service->SendMesh(ctx, req, resp);
             }, this)));
}

MeshService::Service::~Service() {
}

::grpc::Status MeshService::Service::SendMesh(::grpc::ServerContext* context, const ::RatSim::MeshData* request, ::RatSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* PointCloudService_method_names[] = {
  "/RatSim.PointCloudService/SendPointCloudWithColor",
};

std::unique_ptr< PointCloudService::Stub> PointCloudService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< PointCloudService::Stub> stub(new PointCloudService::Stub(channel, options));
  return stub;
}

PointCloudService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_SendPointCloudWithColor_(PointCloudService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status PointCloudService::Stub::SendPointCloudWithColor(::grpc::ClientContext* context, const ::RatSim::PointCloudWithColor& request, ::RatSim::Status* response) {
  return ::grpc::internal::BlockingUnaryCall< ::RatSim::PointCloudWithColor, ::RatSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_SendPointCloudWithColor_, context, request, response);
}

void PointCloudService::Stub::async::SendPointCloudWithColor(::grpc::ClientContext* context, const ::RatSim::PointCloudWithColor* request, ::RatSim::Status* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::RatSim::PointCloudWithColor, ::RatSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendPointCloudWithColor_, context, request, response, std::move(f));
}

void PointCloudService::Stub::async::SendPointCloudWithColor(::grpc::ClientContext* context, const ::RatSim::PointCloudWithColor* request, ::RatSim::Status* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_SendPointCloudWithColor_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Status>* PointCloudService::Stub::PrepareAsyncSendPointCloudWithColorRaw(::grpc::ClientContext* context, const ::RatSim::PointCloudWithColor& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::RatSim::Status, ::RatSim::PointCloudWithColor, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_SendPointCloudWithColor_, context, request);
}

::grpc::ClientAsyncResponseReader< ::RatSim::Status>* PointCloudService::Stub::AsyncSendPointCloudWithColorRaw(::grpc::ClientContext* context, const ::RatSim::PointCloudWithColor& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncSendPointCloudWithColorRaw(context, request, cq);
  result->StartCall();
  return result;
}

PointCloudService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      PointCloudService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< PointCloudService::Service, ::RatSim::PointCloudWithColor, ::RatSim::Status, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](PointCloudService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::RatSim::PointCloudWithColor* req,
             ::RatSim::Status* resp) {
               return service->SendPointCloudWithColor(ctx, req, resp);
             }, this)));
}

PointCloudService::Service::~Service() {
}

::grpc::Status PointCloudService::Service::SendPointCloudWithColor(::grpc::ServerContext* context, const ::RatSim::PointCloudWithColor* request, ::RatSim::Status* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace RatSim

